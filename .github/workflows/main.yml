name: Bot L4 y L7

on:
  workflow_dispatch:
    inputs:
      manual_token:
        description: 'Token manual (opcional si KEYS est√° configurado)'
        required: false
        type: string
  push:
    branches:
      - main

jobs:
  build-and-run:
    runs-on: ubuntu-latest
    
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Set up Python
        uses: actions/setup-python@v4
        with:
          python-version: '3.11'

      - name: Set up Go
        uses: actions/setup-go@v4
        with:
          go-version: '1.21'

      - name: Install Go dependencies
        run: |
          go mod init bot 2>/dev/null || true
          go get github.com/sandertv/go-raknet 2>/dev/null || echo "‚ö†Ô∏è  go-raknet opcional"
          go get github.com/sirupsen/logrus 2>/dev/null || echo "‚ö†Ô∏è  logrus opcional"

      - name: Install Python dependencies
        run: |
          python -m pip install --upgrade pip
          pip install discord.py

      - name: Install build tools
        run: |
          sudo apt-get update
          sudo apt-get install -y build-essential gcc g++ make libpcap-dev libssl-dev

      - name: Build binaries
        run: |
          echo "=== COMPILANDO BINARIOS ==="
          
          # Funci√≥n para compilar
          compile_binary() {
            local source="$1"
            local binary="$2"
            local libs="$3"
            
            if [ -f "$source" ]; then
              echo "üî® $source ‚Üí $binary"
              gcc -O3 -pthread "$source" -o "$binary" $libs 2>/dev/null && {
                chmod +x "$binary"
                echo "  ‚úÖ $binary"
              } || echo "  ‚ö†Ô∏è  Error $binary"
            fi
          }
          
          # Compilar cada m√©todo
          compile_binary "udpbypass.c" "udpbypass" ""
          compile_binary "tcp.c" "tcp" ""
          compile_binary "tcp-syn.c" "tcp-syn" "-lpcap"
          compile_binary "tcp-ack.c" "tcp-ack" "-lpcap"
          compile_binary "tcp-tls.c" "tcp-tls" "-lssl -lcrypto"
          compile_binary "dns.c" "dns" ""
          compile_binary "ntp.c" "ntp" ""
          compile_binary "httpsraw.c" "httpsraw" ""
          compile_binary "tls.c" "tls" "-lssl -lcrypto"
          compile_binary "httpsrequest.c" "httpsrequest" ""
          
          # M√©todos existentes
          compile_binary "udp.c" "udp" ""
          compile_binary "udphex.c" "udphex" ""
          compile_binary "udppps.c" "udppps" ""
          compile_binary "ovh.c" "ovh" "-lpcap"
          compile_binary "udppayload.c" "udppayload" ""
          
          echo ""
          echo "üìÇ Ejecutables compilados:"
          find . -maxdepth 1 -type f -executable ! -name "*.py" ! -name "*.go" 2>/dev/null | sort

      - name: CONFIGURAR TOKEN (M√∫ltiples fuentes)
        id: setup_token
        run: |
          echo "=== BUSCANDO TOKEN ==="
          
          # 1. Intentar desde secret KEYS
          if [ -n "${{ secrets.KEYS }}" ]; then
            echo "‚úÖ Token encontrado en secret KEYS"
            echo "${{ secrets.KEYS }}" > token.txt
            echo "TOKEN_SOURCE=secret" >> $GITHUB_ENV
            
          # 2. Intentar desde input manual
          elif [ -n "${{ github.event.inputs.manual_token }}" ]; then
            echo "‚úÖ Token encontrado en input manual"
            echo "${{ github.event.inputs.manual_token }}" > token.txt
            echo "TOKEN_SOURCE=manual" >> $GITHUB_ENV
            
          # 3. Verificar si token.txt ya existe
          elif [ -f "token.txt" ] && [ -s "token.txt" ]; then
            echo "‚úÖ Usando token.txt existente"
            echo "TOKEN_SOURCE=file" >> $GITHUB_ENV
            
          # 4. Error cr√≠tico
          else
            echo ""
            echo "‚ùå‚ùå‚ùå ERROR: NO SE ENCONTR√ì TOKEN ‚ùå‚ùå‚ùå"
            echo ""
            echo "SOLUCIONES:"
            echo ""
            echo "1. CONFIGURA SECRET EN GITHUB:"
            echo "   ‚Ä¢ Ve a Settings ‚Üí Secrets and variables ‚Üí Actions"
            echo "   ‚Ä¢ Crea un New repository secret"
            echo "   ‚Ä¢ Nombre: KEYS"
            echo "   ‚Ä¢ Valor: [TU TOKEN DE DISCORD]"
            echo ""
            echo "2. USA INPUT MANUAL:"
            echo "   ‚Ä¢ Ejecuta workflow_dispatch"
            echo "   ‚Ä¢ Pega tu token en 'manual_token'"
            echo ""
            echo "3. CREA token.txt MANUALMENTE:"
            echo "   ‚Ä¢ Crea archivo token.txt en el repositorio"
            echo "   ‚Ä¢ Escribe tu token dentro"
            echo ""
            exit 1
          fi
          
          # Verificar token
          if [ -f "token.txt" ]; then
            TOKEN_LENGTH=$(wc -c < token.txt)
            echo "Token guardado en token.txt"
            echo "Tama√±o: $TOKEN_LENGTH caracteres"
            
            # Validar formato b√°sico
            if [ $TOKEN_LENGTH -lt 50 ]; then
              echo "‚ö†Ô∏è  Advertencia: Token muy corto (m√≠nimo 59 caracteres)"
            fi
          fi

      - name: VERIFICAR TOKEN
        run: |
          echo "=== VERIFICANDO TOKEN ==="
          
          if [ ! -f "token.txt" ]; then
            echo "‚ùå ERROR: token.txt no se cre√≥"
            exit 1
          fi
          
          TOKEN_CONTENT=$(cat token.txt)
          TOKEN_LENGTH=${#TOKEN_CONTENT}
          
          echo "Token le√≠do: $TOKEN_LENGTH caracteres"
          echo "Primeros 5 chars: ${TOKEN_CONTENT:0:5}..."
          
          if [ $TOKEN_LENGTH -eq 0 ]; then
            echo "‚ùå ERROR: Token vac√≠o"
            exit 1
          fi
          
          echo "‚úÖ Token verificado"

      - name: Run bot
        run: |
          echo "====================================="
          echo "üöÄ INICIANDO BOT UDP/TCP/AMP/L7"
          echo "====================================="
          echo "Fuente del token: ${{ env.TOKEN_SOURCE }}"
          echo ""
          
          # Verificar archivos cr√≠ticos
          if [ ! -f "bot.py" ]; then
            echo "‚ùå ERROR: bot.py no encontrado"
            exit 1
          fi
          
          if [ ! -f "token.txt" ]; then
            echo "‚ùå ERROR: token.txt no existe"
            exit 1
          fi
          
          echo "‚úÖ Archivos verificados"
          echo "üéÆ M√©todos disponibles seg√∫n ejecutables:"
          
          # Mostrar m√©todos disponibles
          for method in udp udphex udppps ovh udppayload udpbypass tcp tcp-syn tcp-ack tcp-tls dns ntp httpsraw tls httpsrequest; do
            if [ -f "$method" ]; then
              echo "  ‚úì $method"
            fi
          done
          
          for go_script in udpflood.go raknet.go; do
            if [ -f "$go_script" ]; then
              echo "  ‚úì $go_script (Go)"
            fi
          done
          
          echo ""
          echo "üîß Compilando scripts Go..."
          if [ -f "udpflood.go" ]; then
            go build -o udpflood udpflood.go 2>/dev/null || echo "‚ö†Ô∏è  udpflood.go"
          fi
          
          if [ -f "raknet.go" ]; then
            go build -o raknet raknet.go 2>/dev/null || echo "‚ö†Ô∏è  raknet.go"
          fi
          
          echo ""
          echo "‚ö° INICIANDO BOT..."
          echo "Modo: Sigiloso (0 mensajes en Discord)"
          echo "====================================="
          
          # Ejecutar bot
          python3 bot.py
          
          echo ""
          echo "====================================="
          echo "ü§ñ BOT FINALIZADO"
          echo "====================================="
